= Java 8 Lambdas
2016-03-09
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../java]

== What's New?
* Functional Programming (Lambdas)
* Default Methods on Interfaces
* Streams
* `Optional`


== Functional Interfaces
[%step]
* A functional interface has exactly one abstract method
* Several interfaces defined in `java.util.function`
** *`Function<T,R>`* - transform something of type *T* to something of type *R*
** *`BiFunction<T,R,S>`* - transform something of type *T* and of type *R* to something of type *S*
** *`Consumer<T>`* - accept something of type *T* (assumes a side-effect results)
** *`Predicate<T>`* - transform something of type *T* to `boolean`
** *`Supplier<R>`* - provides one or more instances of type *R*

=== Implementing Functional Interfaces
* Can just create instances of the functional interfaces (Java 7 style)

[source, java]
-----
class IsEvenPredicate implements Predicate<Integer> {
  @Override
  public boolean test(Integer i) {
    return i%2 == 0;
  }
}
-----
* More concise to use lambda expressions

=== Lambdas

[source, java]
-----
Predicate<Integer> isEvenPredicate = (i) -> i%2 == 0;

Function<String, Integer> myFunction = (s) -> s.length();
-----

[%step]
* `myFunction` is a `Function` accepting a `String` and returning an `Integer`
** a reference to something that does computation
* The *core principle* of Functional Programming is that functions are *values*
** Like `String` or `int`
** Can be passed-in and returned-from methods

=== Anonymous Lambda expressions
* Anywhere a functional interface is expected, an anonymous lambda expression can be used

[source, java]
-----
IntPredicate isEven = (i) -> i%2 == 0;

IntStream.rangeClosed(0,10)
      .filter(isEven)
-----
Could be written

[source, java]
-----
IntStream.rangeClosed(0,10)
      .filter( i -> i%2 == 0 )
-----


== Default Methods in Interfaces
* Mainly to help the migration to Lambdas
* Opens up some useful design options

=== The Java 7 way
* Up to Java 7, interfaces
** Define an API
** Hold static data
** Allow multiple inheritance of APIs

[source, java]
-----
public interface Developer {
  public static final Period DEFAULT_ESTIMATE = Period.ofDays(2);
  public Software code(Specification spec, Coffee c);
  public Period estimate(Specification spec);
}
-----

=== Default Methods
* A common pattern has been to define an interface and an abstract class with default implementation

[source, java]
-----
public abstract class DefaultDeveloper implements Developer {
  public Period estimate(Specification spec) {
    return DEFAULT_ESTIMATE;
  }
}
-----
* Java 8 lets us do both in the same place

[source, java]
-----
public interface Developer {
  public static final Period DEFAULT_ESTIMATE = Period.ofDays(2);
  public Software code(Specification spec, Coffee c);
  default Period estimate(Specification spec) {
    return DEFAULT_ESTIMATE;
  }
}
-----
* *N.B.* No inheritance of _state_

=== Multiple Inheritance
* Until Java 8 multiple inheritance of _behaviour_ wasn't allowed
** Diamond Inheritance Problem
* Java 8 defines strict rules of precendence
** The class (and the class inheritance heirarchy)
** The 'most specific' implemented interface
*** _how close it is in the interface inhertiance heirarchy_
** Explicit disambiguation (or reuse)

=== Multiple Inheritance

[source, java]
-----
public interface JavaDeveloper extends Devloper {
  default Software code(Specification spec, Coffee c) {
    Software sw = new JavaSoftware(spec);
    while(!coffee.empty()) {
      sw.improve(spec);
    }
    return sw;
  }
}

public interface Designer {
  default Specification improve(Specification spec) {
    return improved(spec);
  }
  default Period estimate(Specification spec) {
    return Period.ofDays(5);
  }
}
-----

=== Multiple Inheritance (Mixins)
[plantuml, "simplified-data-model", png, scaledwidth="100%"]
----
@startuml
interface Developer {
  Period estimate(Specification spec)
  Software code(Specification spec, Coffee c)
}
interface JavaDeveloper extends Developer {
  Software code(Specification spec, Coffee c)
}
interface Designer {
  Period estimate(Specification spec)
  Specification improve(Specification spec)
}
class SeniorDeveloper implements JavaDeveloper, Designer {
  Period estimate(Specification spec)
}
@enduml
----

[source, java]
-----
public class SeniorDeveloper implements JavaDeveloper, Designer {
  public Period estimate(Specification spec) {
    return JavaDeveloper.super.estimate(spec)
            .plus(Designer.super.estimate(spec));
  }
}
-----

=== Method References
* Can also now define `static` methods in interfaces as well as classes
** Not inherited, but can be referred to

[source, java]
-----
IntStream.rangeClosed(0,10)
      .filter(i -> i%2 ==0)
      .reduce(Integer::sum);
-----
* Java 8 uses default & static methods to enrich the existing APIs
** `Integer::sum` is a Functional Interface `java.util.function.BinaryOperator`

=== Questions?


== `Optional`

* Why are `null` references there at runtime?
** Intentional
*** Equivalent to 'nothing'
*** An error flag
** Unintentional
*** Uninitialised
*** Set during execution (e.g. bad return from a method call)

=== The `Optional` Type
* Express the idea that an API may not return a result *e.g.*

[source, java]
-----
  public Booking search(String name) { ... }
-----
may fail to find a booking

* Use an `Optional` to make it part of the API

[source, java]
-----
  public Optional<Booking> search(String name) { ... }
-----

=== Creating `Optional` values
[%step]
* *`Optional.of(value)`* - definitely a non-null value
* *`Optional.empty()`* - definitely *not* a value
* *`Optional.ofNullable(value)`* - a value which _might_ be null

=== Using `Optional` values
[%step]
* *`opt.isPresent()`* - explicitly test the value
* *`opt.get()`* - get the wrapped value (throws `NoSuchElementException` if there is no value present !)
* *`opt.orElse("default value")`* - get the wrapped value, or the default if not present
* *`opt.orElseGet( () -> lookupDefault())`* - get the wrapped value, or lazily compute if not present
* *`opt.orElseThrow( () -> throw new IllegalStateException("..."))`* - throw a lazily-constructed exception if not present

=== Using `Optional` values
* *`opt.map`* - for `Stream` processing without breaking the chain to check for missing values

[source, java]
-----
Optional<FileInputStream> fis =
  names.stream().filter(name -> !isProcessedYet(name))
                .findFirst()
                .map(name -> new FileInputStream(name));
-----

* Here, `findFirst` returns an `Optional<String>`,
* `map` returns an `Optional<FileInputStream>` for the desired file if one exists,
** or an `empty` if not.

=== `Optional` gotchas
* Not `Serializable`
* No object-identity-related guarantees for Optionals
** `myOptional1 == myOptional2` tells you nothing
** `synchronized(myOptional)` has unpredictable effects - it might block forever.
* Not the same as e.g. Scala's `Option` type
** Only designed to be a wrapper for return types
** See the *javaslang* project for a real alternative

=== Questions?


== Streams

* The idea of chaining together operations to get a result is familiar

[plantuml, "stream-processing", png, scaledwidth="100%"]
----
@startuml
(*) -> filter
-> transform
-> summarise
-> (*)

@enduml
----

=== UNIX command line
[source]
-----
grep 'GCA' records.csv | cut -d',' -f 10,11,12 | awk -F',' {print $1+$2+$3}
-----

=== SQL
[source, sql]
-----
select f3, sum(f1), avg(f2)
  from relation
  where f1 > 500
  groupby f3
  having avg(f2) > 50
-----

=== Java 8 Streams

* *Not* the same as `java.io.InputStream`

[source, java]
-----
final int totalForAllMonths_GCA = COINSData
                .records.stream()
                .filter((r) -> r.category.equals("GCA"))
                .map((r) ->
                  r.april_2010_mth +
                  r.may_2010_mth +
                  r.june_2010_mth)
                .reduce(Integer::sum)
                .get();

        System.out
          .println("The total for april, may and june for GCA records is "
            + totalForAllMonths_GCA);
-----

=== `Collection.stream()`
[source]
-----
java.util.Collection
Stream<E> stream()
Returns a sequential Stream with this collection as its source.
-----

and

[source, java]
-----
java.util.stream
public interface Stream<T>
extends BaseStream<T, Stream<T>>
A sequence of elements supporting sequential and parallel aggregate
operations.
-----

=== `Stream` API
* `filter(Predicate predicate)`
** the elements of this stream that match the given predicate.

[source, java]
-----
stream.filter(s -> !s.isEmpty())
-----
* `map(Function mapper)`
** apply the given function to the elements of this stream.

[source, java]
-----
stream.map(s -> s.toUpper())
-----
* `collect(Collector collector)`
** Produce a summary result from all the elements of the stream

[source, java]
-----
stream.collect(Collectors.toList())
stream.collect(Collectors.groupingBy(i -> i % 2 == 0))
-----

=== `Stream` API
* `sorted()`
** return a sorted `Stream` (*expensive*!)
* `forEach(Consumer action)`

[source, java]
-----
stream.forEach(s -> System.out.println(s) )
-----
* and many more.  See the `java.util.stream` package javadoc

=== `Stream` gotchas
[%step]
* Processing steps must be stateless
** Don't use or modify external state
* Complexity
** Chained anonymous operations can build into complex logic
** Hard to test/debug
** So, pull out into named lambda functions
* Order matters - terminal vs. intermediate operations
** filter first
** avoid sorting
** terminal operations `count()` or `forEach()` come last

=== `Stream` examples
[source, java]
-----
// All trasactions in 2011, sorted by value
List<Transaction> tr2011 = transactions.stream()
  .filter(transaction -> transaction.getYear() == 2011)
  .sorted (comparing(Transaction::getValue))
  .collect(toList());

// All traders in Cambridge, sorted by name
List<Trader> traders = transactions.stream()
  .map(Transaction::getTrader)
  .filter(trader -> trader.getCity().equals("Cambridge"))
  .distinct()
  .sorted(comparing(Trader::getName))
  .collect(toList());
-----

=== `Stream` Cheatsheet

http://zeroturnaround.com/wp-content/uploads/2016/01/Java-8-Streams-cheat-sheet-v3.png

image::Java-8-Streams-cheat-sheet-v3.png[width=80%]

=== Questions?


== Examples

=== Removing Duplication

* Our codebase had a common pattern, repeated 100s of times

[source, java]
-----
try {
  session = openSession();
  tx = connection.startTransaction();
  // Do some DB operation
  result = session.createQuery(...);
  tx.commit();
  // Do some more work with the result
  return transform(result);
}
// Several of these
catch (SomeExceptions e) { /* Handle & rollback */ }
finally { session.close(); }
-----

=== Pull out the common code

[source,java]
-----
public <T> Optional<T>
      tryInTransaction(Function<DatabaseSession, T> preCommitWork) {
  try {
    session = openSession();
    tx = connection.startTransaction();
    // call the supplied function
    T result = preCommitWork.apply(session);
    tx.commit();
    return Optional.ofNullable(result); // The result may be null
  }
  // Several of these
  catch (SomeExceptions e) { /* Handle & rollback */ }
  finally { session.close(); }
}
-----

=== Before

[source,java]
-----
try {
  session = openSession();
  tx = connection.startTransaction();
  enterprisePojo =
    getPersistentEnterprise(session, serviceConfig.getEnterpriseName());
  tx.commit();
  if (enterprisePojo != null) {
      enterpriseList = EnterpriseConverter.convert(Lists.newArrayList(p));
  } else {
      throw new NotFoundException("No Enterprise found in database.");
  }
  return enterpriseList;
}
catch (Exception e) { /* Handle & rollback */ }
finally { session.close(); }
-----

=== After

* 'Noise' is removed (reuse via lambda parameter)
* Error handling is separated from the happy-path (`Optional`)

[source,java]
-----
Optional<EnterprisePojo> enterprisePojo =
  tryInTransaction(s ->
    getPersistentEnterprise(s, serviceConfig.getEnterpriseName()) )

return enterprisePojo
  .map(p ->  EnterpriseConverter.convert(Lists.newArrayList(p)))
  .orElseThrow(() -> new NotFoundException("No Enterprise found in database."));
-----



== End














== Extras

== javaslang library

=== Retry

* Uses the javaslang `Try` - an abstraction of an operation that _might_ fail

[source, java]
-----
public final class Retry<T> {
  // Fluent builder methods here

  public Try<T> operation(CheckedSupplier<T> operation) {
    int tries = 1;
    while (true) {
      try {
        T result = operation.get(); // <---- call the supplied function
        return Try.success(result);
      } catch (Throwable e) {
        if (tries < maxTimes) {
          // Retry logic here
        } else {
          return Try.failure(e);
        }
      }
    }
  }
}
-----

=== Retry

[source, java]
-----
Retry<String> retry = Retry.times(HTTP_ATTEMPTS).pausing(5, SECONDS);

toggleList = retry
  .operation(() -> {
    // May fail with an exception
    httpClient.getRequest(uri.getPath())
  })
  .map(json -> {
    // Transform the successful result (after retries as appropriate)
    Arrays.asList(gson.fromJson(json, Toggles.class).toggles)
  })
  .getOrElseThrow(() -> {
      // Either the result of the transformation, or throw a suitable error
      // N.B. could also provide a default with `getOrElse(...)`
      new RuntimeException("Failed to retrieve config after retrying")
  });
-----

== Questions?
